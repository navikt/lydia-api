/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package no.nav.lydia

import com.auth0.jwk.JwkProviderBuilder
import io.ktor.application.*
import io.ktor.auth.*
import io.ktor.auth.jwt.*
import io.ktor.features.*
import io.ktor.metrics.micrometer.*
import io.ktor.routing.*
import io.ktor.serialization.*
import io.ktor.server.engine.*
import io.ktor.server.netty.*
import kotlinx.coroutines.runBlocking
import no.nav.lydia.appstatus.Metrics
import no.nav.lydia.appstatus.healthChecks
import no.nav.lydia.appstatus.metrics
import no.nav.lydia.sykefraversstatistikk.SykefraversstatistikkRepository
import no.nav.lydia.sykefraversstatistikk.api.sykefraversstatistikk
import no.nav.lydia.sykefraversstatistikk.import.StatistikkConsumer
import java.util.concurrent.TimeUnit
import javax.sql.DataSource

fun main() {
    runBlocking {
        startLydiaBackend()
    }
}

fun startLydiaBackend() {
        val naisEnv = NaisEnvironment()
        val dataSource = createDataSource(database = naisEnv.database)
        runMigration(dataSource = dataSource)

        statistikkConsumer(naisEnv = naisEnv)

        embeddedServer(factory = Netty, port = 8080) {
            lydiaRestApi(security = naisEnv.security, dataSource = dataSource)
        }.also {
            // https://doc.nais.io/nais-application/good-practices/#handles-termination-gracefully
            it.addShutdownHook {
                it.stop(3, 5, TimeUnit.SECONDS)
            }
        }.start(wait = true)
}

fun Application.lydiaRestApi(security: Security, dataSource: DataSource) {
    install(ContentNegotiation) {
        json()
    }
    install(IgnoreTrailingSlash)

    install(MicrometerMetrics) {
        registry = Metrics.appMicrometerRegistry
    }

    val jwkProvider = JwkProviderBuilder(security.azureConfig.jwksUri)
        .cached(10, 24, TimeUnit.HOURS)
        .rateLimited(10, 1, TimeUnit.MINUTES)
        .build()
    install(Authentication) {
        jwt {
            verifier(jwkProvider, security.azureConfig.issuer)
            validate { credentials ->
                try {
                    requireNotNull(credentials.payload.audience) {
                        "Auth: Missing audience in token"
                    }
                    require(credentials.payload.audience.contains(security.azureConfig.audience)) {
                        "Auth: Valid audience not found in claims"
                    }
                    JWTPrincipal(credentials.payload)
                } catch (e: Throwable) {
                    log.error("Feil under autentisering")
                    log.error(e.message)
                    null
                }
            }
        }
    }

    routing {
        healthChecks()
        metrics()
        authenticate {
            sykefraversstatistikk(SykefraversstatistikkRepository(dataSource))
        }
    }
}
fun statistikkConsumer(naisEnv: NaisEnvironment) =
        StatistikkConsumer.apply {
            create(naisEnv = naisEnv)
            run()
        }

